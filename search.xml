<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[antd design pro中使用typescript]]></title>
    <url>%2F2019%2F02%2F26%2Fantd-design-pro%E4%B8%AD%E4%BD%BF%E7%94%A8typescript%2F</url>
    <content type="text"><![CDATA[index.js1234import React, &#123; Component, PureComponent &#125; from 'react'export default class TagSelect extends Component&#123;&#125; TagSelectionOption.d.ts12345678import * as React from 'react';export interface ITagSelectOptionProps &#123; value: string | number; style?: React.CSSProperties;&#125;export default class TagSelectOption extends React.Component&lt;ITagSelectOptionProps, any&gt; &#123;&#125; index.d.ts12345678910111213141516import * as React from 'react'import TagSelectOption from './TagSelectOption'export interface ITagSelectProps &#123; onChange?: (value: string[]) =&gt; void; expandable?: boolean; value?: string[] | number[]; style?: React.CSSProperties; hideCheckAll?: boolean;&#125;export default class TagSelect extends React.Component&lt;ITagSelectProps, any&gt;&#123; public static Option: typeof TagSelectOption private children: | React.ReactElement&lt;TagSelection&gt; | Array&lt;React.ReactElement&lt;TagSeletion&gt;&gt;;&#125;]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用fetch实现文件下载]]></title>
    <url>%2F2019%2F01%2F23%2F%E4%BD%BF%E7%94%A8fetch%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[文档地址：https://www.yuque.com/ant-design/course/wvbsue 当我们要实现一个下载的功能时，浏览器会通过文件的MIME类型来决定是直接打开文件，还是下载文件。比如：当需要下载的文件是图片或者视频时，浏览器会自动打开文件。最近遇到了一个需要下载视频的需求，在这里记录一下过程。 项目是antd design pro搭建的，视频的下载这个过程是使用fetch去模拟a标签的下载过程。代码示例如下：12345678910111213141516import fetch from 'dva/fetch'fetch('http://somehost/somefile.zip') // 1. .then(res =&gt; res.blob()) .then(blob =&gt; &#123; // 2. var a = document.createElement('a'); var url = window.URL.createObjectURL(blob); var filename = 'myfile.zip'; a.href = url; a.download = filename; // 3. a.click(); // 4. window.URL.revokeObjectURL(url); &#125;)) fetch 一个接口获取其内容并转成 blob 对象。 将 blob 对象使用 createObjectURL 方法转化成 ObjectURL，等同于一个下载地址链接。 创建一个 a 标签，并赋予 ObjectURL 且执行一次 click。 通过 revokeObjectURL 回收 ObjectURL。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>fetch</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序登录及注册]]></title>
    <url>%2F2019%2F01%2F21%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E5%8F%8A%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[关于微信小程序的登录及第一次注册的过程 1.登录过程说明：图中画红线的地方是前端需要处理的过程， 首先获取获取用户信息wx.getUserInfo()允许调用小程序的wx.login()，获取临时登录凭证code/iv/encryptedData —code–&gt; 用code发起服务请求，获取自定义登录态token自定义登录态存入本地storagewx.setStorageSync(&quot;token&quot;, token) &lt;–token— token发起业务请求，header头部携带自定义登录态token123456789wx.request(&#123; url: parm.url, data: parm.data, header: &#123; token: app.globalData.GetToken() &#125;, method: param.method, success:pram.success&#125;) —携带token–&gt;返回数据 2.静默登录 只需要想服务端发送code]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react高阶函数——页面中弹出框的打开和关闭]]></title>
    <url>%2F2018%2F12%2F27%2Freact%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%BC%B9%E5%87%BA%E6%A1%86%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%2F</url>
    <content type="text"><![CDATA[前言：在最近的项目中，多个页面都有弹出框的功能，所以我写了一个高阶组件，减少了代码量，顺便学习了一下高阶组件。 在src文件夹下建立名为hoc的子文件夹，以后的高阶组件都写在这个文件夹里面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import React, &#123; PureComponent &#125; from 'react';import &#123; connect &#125; from 'dva';import &#123; notification &#125; from 'antd';const ModalSubmitHoc = WrappedComponent =&gt; &#123; return connect((&#123; &#125;) =&gt; (&#123; &#125;))( class extends PureComponent &#123; state=&#123; modalParams:&#123; visible: false, visibleObject: &#123;&#125; &#125;, modalMethods:&#123; &#125;, &#125; constructor()&#123; super() this.state=&#123; modalParams:&#123; visible: false, visibleObject: &#123;&#125; &#125;, modalMethods: &#123; openModal:this.openModal, closeModal:this.closeModal, openOneModal: this.openOneModal, closeOneModal: this.closeOneModal, submitModal:this.submitModal, getModalVisibleObject: this.getModalVisibleObject &#125; &#125; &#125; // 生成多少个弹窗的visible getModalVisibleObject = (visibleArr) =&gt; &#123; let c = &#123;&#125; visibleArr.map((_)=&gt;&#123; c[_] = false &#125;) this.setState(&#123; visibleObject: c &#125;) &#125; // 页面内只有一个弹窗 openModal = (visible=true) =&gt; &#123; this.setState(&#123;modalParams:&#123;visible&#125;&#125;) &#125; closeModal = (visible=false) =&gt; &#123; this.setState(&#123;modalParams:&#123;visible&#125;&#125;) &#125; // 页面内有多个弹窗 openOneModal = (visibleName) =&gt; &#123; this.setState(&#123; modalParams: &#123; visibleObject: &#123; [visibleName]: true &#125; &#125; &#125;) &#125; closeOneModal = (visibleName) =&gt; &#123; this.setState(&#123; modalParams: &#123; visibleObject: &#123; [visibleName]: false &#125; &#125; &#125;) &#125; resetFields = () =&gt; &#123; const &#123; form &#125; = this.props; form.resetFields() &#125; /** * 提交modal * @param &#123;String&#125; dispatchType dispatch的type * @param &#123;Object&#125; values 提交的参数 * @param &#123;string&#125; visibleName 提交的弹窗名字 */ submitModal = (dispatchType, values, visibleName) =&gt; &#123; const &#123; dispatch &#125; = this.props; dispatch(&#123; type:`$&#123;dispatchType&#125;`, payload: &#123; ...values, &#125;, callback: (code, message, description) =&gt; &#123; if(code)&#123; notification.success(&#123;message&#125;) this.resetFields() if(visibleName)&#123; this.closeOneModal(visibleName) &#125;else &#123; this.closeModal() &#125; &#125;else &#123; notification.error(&#123;message, description&#125;) &#125; &#125; &#125;) &#125; render() &#123; const newProps = &#123;...this.props,...this.state&#125;; return &lt;WrappedComponent &#123;...newProps&#125; /&gt;; &#125; &#125; );&#125;;export default ModalSubmitHoc; 在页面中使用页面通过获取props来使用高阶组件的参数和方法 123456import ModalSubmitHoc from '@/hoc/ModalSubmitHoc'@ModalSubmitHocexport default class 组件 extends PureComponent&#123;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>高阶组件HOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[antd design pro的用法]]></title>
    <url>%2F2018%2F09%2F11%2Fantd-design-pro%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[antd design pro的用法namespace:state:effects:reducer: 拿回数据需要做的事情：model中写namespace（全局的state的名字）/state（全局state中的属性）/effects（发起请求拿回数据，触发reducer改变state）/reducer（改变数据）/subscriptions（监控路由的变化,键盘输入，地理位置，返回一个函数）mock中写这个请求对应的数据。在mock中对接收的数据，及返回的数据进行处理，再将最终的结果进行返回。service中写用request发起这个请求，返回数据 123456789101112131415161718192021222324252627// 监控各种变化subscriptions&#123; setup(&#123; dispatch,history &#125;) &#123;// 方法名可以随便定义，当监听有变化的时候就会依次执行这的变化 return history.listen((&#123; pathname, search,query &#125;) =&gt; &#123;// 表示路由变化时，执行以下语句 //console.log(`query = $&#123;JSON.stringify(query)&#125;`); if(pathname.indexOf('/list/table-list')&gt;=0)&#123; const &#123;page=1 , name,category:type&#125; = query; console.log('page = ',page, ' , name = ',name,',type =',type,); dispatch(&#123;type:'fetch',payload:&#123;page,name,type,from:'unchecks','status':'EXAMINE'&#125;&#125;); &#125;else if(pathname.indexOf('/list/basic-list')&gt;=0)&#123; const &#123;page=1 , name,category:type&#125; = query; dispatch(&#123;type:'fetch',payload:&#123;page,name,type,from:'tracks',&#125;&#125;); &#125;else if(pathname.indexOf('/list/card-list')&gt;=0)&#123; const &#123;page=1 , name,category:type&#125; = query; dispatch(&#123;type:'fetch',payload:&#123;page,name,type,from:'rolleds','status':'FINISH'&#125;&#125;); &#125; &#125;); &#125; setup(&#123; dispatch, history &#125;) &#123; // 这里的方法名可以随便命名，当监听有变化的时候就会依次执行这的变化 window.onresize = () =&gt; &#123; //这里表示的当浏览器的页面的大小变化时就会触发里面的dispatch方法 dispatch (type:"save") &#125;&#125;, state定义初始状态，reducer定义相关函数，来修改状态。 1234567export default &#123; namespace: '名字', state: '初始状态' &amp; &#123;resultCode,resultMsg&#125;, reducer: &#123; updateState(state, &#123;payload&#125;) &#125;&#125; effects描述当前发生的事情，是改变state的方法。若需要发起请求后，再改变状态，需要在effects定义的函数中发起请求。请求后返回的参数传递到put函数中，触发reducer，进而修改状态。 123456789effects: &#123; *fetchRes(_, &#123; call, put&#125;)&#123; const res = yield call(请求函数,[请求参数]); yield put(&#123; type:'updateState', payload: res &#125;) &#125;&#125; 请求函数放在service文件夹中，通过封装的request的函数向mock发起请求。1234567891011121314151617181920212223242526// mock/~.jsconst getNotice = (req, res) =&gt; &#123; res.json([&#123; uname:'haha', des:'你好' &#125;])&#125;export default &#123; 'GET /api/···': getNotices,&#125;;// service/api export async function query(params)&#123; // 带参数的get请求 return request(`/api/···$&#123;strinify(params)&#125;`) // post请求 return request('/api/···', &#123; method: 'POST', body: params &#125;)&#125;// utils/requestexport default function request(url, options)&#123; ~~~&#125; effects只是描述这件事情发生后的情况，并没有触发。所以在视图组件中，需要通过dispatch({ type: ‘’})的方法，触发当前发生的事情，然后执行2中的顺序，待状态修改完成，会自动渲染到视图中形成新的数据状态。想要调用dispatch需要加上connect 123456componentDidMount()&#123; const &#123; dispatch &#125; = this.props; dispatch(&#123; type:namespace+'/'+effects中的描述事件的方法 &#125;)&#125; 重要的一点是，若想在视图中使用state，并更改state，也就是把model和组件串起来，需要用到@connect，是connect的装饰器，在外面包裹了一层state。 1234@connect(( profile, loading )=&gt;(&#123; profile, loading: loading.effects[namespace+'/'+effects中的描述事件的方法]&#125;)) connect里面的参数，是全局里面的state，将全局state注入到当前的组件中，当前组件用this.props取出。loading属性是加载时调用此请求 总结：model的流程大致是 store(View -&gt; effects -&gt; reducer -&gt; state -&gt; view)关于发送请求的流程是 view -&gt; sevice发起请求 -&gt; mock返回数据 -&gt; model更改状态 -&gt; view 菜单栏 导航信息左侧菜单栏文字信息修改：zh-CN.js（中文配置）右上头部信息更改： componennts - GlobalHeader - RightContent.js右上铃铛通知：ZComponent - MyNotifyIcon.js面包屑导航：components - PageHeaderWrapper - index.js 修改breadcrumbList的参数 [{title:’’, name: ‘’, href: ‘’}] 点击跳转 传参123import &#123;routerRedux&#125; from 'dva/router' const &#123;dispatch&#125; = this.props; dispatch(routerRedux.push(&#123;pathname:'/profile/advanced', params/query/search: `参数`&#125;)); 有两种跳转方式：第一种是 import { routerRedux } from ‘dva/router’;第二种是 import router from ‘umi/router’;router.push({pathname:路径,params/query/search:参数) = dispatch(routerRedux.push({pathname:路径,params/query/search:参数})) 123456router.go(n) //这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)router.push(location) //想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。router.replace(location) //跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。 跳转前确认：有一个生命周期钩子：routerWillLeave(){} Browser History：地址形式https://xxx.com/ccc/cc/, 访问指定urlHash History: 地址形式https://xxx.com/#/ccc/cc, 以 # 后面的路径进行处理 react-router官方推荐使用browserHistory首先 browserHistory 其实使用的是 HTML5 的 History API，浏览器提供相应的接口来修改浏览器的历史记录；而 hashHistory 是通过改变地址后面的 hash 来改变浏览器的历史记录； History API 提供了 pushState() 和 replaceState() 方法来增加或替换历史记录。而 hash 没有相应的方法，所以并没有替换历史记录的功能。但 react-router 通过 polyfill 实现了此功能，具体实现没有看，好像是使用 sessionStorage。 另一个原因是 hash 部分并不会被浏览器发送到服务端，也就是说不管是请求 http://domain.com/index.html#foo 还是 http://domain.com/index.html#bar ，服务只知道请求了 index.html 并不知道 hash 部分的细节。而 History API 需要服务端支持，这样服务端能获取请求细节。 还有一个原因是因为有些应该会忽略 URL 中的 hash 部分，记得之前将 URL 使用微信分享时会丢失 hash 部分。 表格组件进行筛选功能时，用onFilter过滤掉不需要的数据，不需要的数据返回false。对时间的顺序进行sorter排序，用两个参数，对需要排序的列进行大小加减。 webpack打包yarn run analyze1yarn run analyze 查看项目打包各个模块的体积 pureComponent和ComponentpureComponent的相当于把Component中的shouldComponentUpdate()钩子函数进行了二次封装，进行了浅比较，当数据相同时就不会重新渲染数据了。用原生的shouldComponentUpdate()通过返回return false阻止render渲染。一般与与第三方的immutable.js库连用，保证数据的唯一性。 高阶组件高阶组件就是没有副作用的纯函数，且该函数接受一个组件作为参数，并返回一个新的组件。最主要的作用是重用组件逻辑。最好是能用父组件就用父组件，因为高阶组件是一种更hack的方法，更具灵活性。区别：父组件可以在元素树上任意使用，高阶组件只应用于一个组件。 高阶组件的用途两点：属性代理和反向继承。通过调用不断将需要的参数传递进去，内部是函数式编程规范进行处理的。 关于&amp;&amp;1 &amp;&amp; 4：返回40 &amp;&amp; 4：返回0这两个执行语句并不直接返回true或false，如果两边的值为boolean类型，那就返回bool类型的值。 设置代理config.js中设置代理1234567891011 publicPath: "http://static.wanxiangzc.com/web/shinva/", base: "/shinva", history: "hash",//改为hash history的方式（默认browserHistory） hash: true, proxy: &#123; "/api": &#123; "target": "http://192.168.2.37:8080/api/", "changeOrigin": true,//（必须）实现跨域 "pathRewrite": &#123; "^/api" : "" &#125; &#125;&#125; 疑难：父元素如何禁止子元素的事件？事件捕获： addEventListener(‘事件名’,funciton(e){e.stop..;e,prevent..}, true) react组件：父元素嵌套子元素，子元素路由不一样。 将子路由写在父路由的routes中，在父组件中用props获取children，组件中直接使用{children}即可。 404路由组件必须放在最下面]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于redux]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%85%B3%E4%BA%8Eredux%2F</url>
    <content type="text"><![CDATA[前言：如果你的应用没那么复杂，就没必要用它。另一方面，Redux 只是 Web 架构的一种解决方案，也可以选择其他方案。 适用场景redux的适用场景：多交互/多数据源 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态设计思想 Web 应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里面。基本概念 storeStore就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。Redux 提供createStore这个函数，用来生成 Store。123import &#123; createStore &#125; from 'redux';const store = createStore(fn); 上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。 stateStore 对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。 当前时刻的 State，可以通过store.getState()拿到。1234import &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 actionState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。 Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置，社区有一个规范可以参考。1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。 可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 Action CreatorView 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。12345678910const ADD_TODO = '添加 TODO';function addTodo(payload) &#123; return &#123; type: ADD_TODO, payload &#125;&#125;const action = addTodo('Learn Redux'); 上面代码中，addTodo函数就是一个 Action Creator。 store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法。1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去。 结合 Action Creator，这段代码可以改写如下。1store.dispatch(addTodo('Learn Redux')); reducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); 上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。 实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); 具体参见见阮一峰的网络日志http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html 中间件react-thunk与异步操作上述的所有是同步的操作，若需要异步操作的话需要使用中间件http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>redux-thunk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于es6]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%85%B3%E4%BA%8Ees6%2F</url>
    <content type="text"><![CDATA[箭头函数的那些事儿由于大括号会被解析为代码块，所以当返回一个对象时，需要在对象外面加一个括号，否则会报错1var getObj = time =&gt; (&#123;type:'哈哈哈',time&#125;)]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信网页版图片上传预览的书写步骤]]></title>
    <url>%2F2018%2F09%2F05%2F%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E7%89%88%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%A2%84%E8%A7%88%E7%9A%84%E4%B9%A6%E5%86%99%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[微信网页版文档：https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115引言：最近做了一个关于图片的功能，包括添加/预览/删除，这里用react的ui框架的一个标签即能实现这些功能。当然还需要调微信端的图像接口。我已经记录了下来。 关于真机调试，网址已记录在前端学习及工具网址 概述微信JS-SDK是微信公众平台面向网页开发者提供的基于微信内的网页开发工具包。 通过使用微信JS-SDK，网页开发者可以借助使用拍照/选图/语音/位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。 使用步骤1. 绑定域名2. 引入js文件 http://res.wx.qq.com/open/js/jweixin-1.4.0.js3. 注入权限验证配置所有需要使用JS-SDK的页面必须先注入配置信息，否则无法调用。12345678910111213141516wx.config(&#123; debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: '', // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [] // 必填，需要使用的JS接口列表&#125;);eg: 需要的JS接口列表jsApiList:['checkJsApi', 'chooseImage', 'uploadImage', 'getLocalImgData', 'onMenuShareAppMessage', ] 4. 通过ready接口处理成功验证12345678910111213141516wx.ready(function()&#123; // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。&#125;);eg: 开启分享功能window.wx.ready(() =&gt; &#123; // 分享给朋友 window.wx.onMenuShareAppMessage(&#123; title, desc, link, imgUrl, type: '', dataUrl: '', &#125;);&#125;); 5.通过error接口处理失败验证123wx.error(function(res)&#123; // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。&#125;); config配置成功后，就可以调用接口了。12345678910111213import &#123; ImagePicker&#125; from 'antd-mobile';&lt;ImagePicker length="4" files=&#123;files&#125; // 删除 onChange=&#123;this.onChange&#125; // 点击图片预览 onImageClick=&#123;this.onImageClick&#125; selectable=&#123;files.length &lt; 4&#125; // 增加图片 onAddImageClick=&#123;this.onAddImageClick&#125;/&gt; 1234567891011121314151617181920// 增加图片：从本地或手机相册选择wx.chooseImage(&#123; count: 1, // 最多选择几张 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) &#123; var localIds = res.localIds; // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片 &#125;&#125;);// 选择图片时在此处出现了IOS兼容性问题此接口仅在 iOS WKWebview 下提供，用于兼容 iOS WKWebview 不支持 localId 直接显示图片的问题 wx.getLocalImgData(&#123; localId: '', // 图片的localID success: function (res) &#123; var localData = res.localData; // localData是图片的base64数据，可以用img标签显示 &#125; &#125;);`页面如何判断当前使用的webview内核：在页面中可通过微信注入的window.wxjs_is_wkwebview变量判断当前使用的webview内核。 iOS微信6.5.3及其之后的版本 window.wxjs_is_wkwebview 为true时是使用WKWebview，为 false或者 “undefine”时是 UIWebview 。` 12345// 预览图片 wx.previewImage(&#123; current: &apos;&apos;, // 当前显示图片的http链接 urls: [] // 需要预览的图片http链接列表 &#125;); 记录我的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// https.js// 微信jssdk签名export function wxShare(options) &#123; const url = window.location.href.replace(/&amp;/g, '@@@'); axios .get('weixin/api/v1/weixin/callback/showdata', &#123; params: &#123; url: url.split('#')[0], &#125;, &#125;) .then(res =&gt; &#123; const &#123; nonceStr, timestamp, signature, appid &#125; = res.data.data; const defaultLink = window.location.href; const &#123; title = '', desc = '', link = defaultLink, imgUrl = '', &#125; = options; window.wx.config(&#123; debug: false, appId: appid, timestamp, nonceStr, signature, jsApiList: [ 'checkJsApi', 'chooseImage', 'uploadImage', 'getLocalImgData', 'onMenuShareAppMessage', ], &#125;); window.wx.ready(() =&gt; &#123; // 分享给朋友 window.wx.onMenuShareAppMessage(&#123; title, desc, link, imgUrl, type: '', dataUrl: '', &#125;); &#125;); &#125;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205// index.jsximport React from 'react';import &#123; List, TextareaItem, Button, WingBlank, ImagePicker,&#125; from 'antd-mobile';import &#123; createForm &#125; from 'rc-form';import styled from 'styled-components';import &#123; rem &#125; from '@/utils/utils';import &#123; wxShare &#125; from '@/api/http';const data = [ &#123; url: 'https://zos.alipayobjects.com/rmsportal/PZUUCKTRIHWiZSY.jpeg', id: '0', &#125;,];class Feedbackkk extends React.Component &#123; state = &#123; files: data, &#125;; componentDidMount() &#123; wxShare(&#123; title: '反馈', &#125;); &#125; //点击图片预览 onImageClick = (index, fs) =&gt; &#123; // console.log(index, fs); 索引 图片数组 let urls = []; fs.forEach(item =&gt; &#123; urls.push(item.url); &#125;); window.wx.previewImage(&#123; current: fs[index].url, // 当前显示图片的http链接 urls: urls, // 需要预览的图片http链接列表 &#125;); &#125;; // 控制删除 onChange = (files, type, index) =&gt; &#123; // console.log(files, type, index); 图片数组 "remove" 删除的索引 this.setState(&#123; files, &#125;); &#125;; // 增加图片 onAddImageClick = e =&gt; &#123; e.preventDefault(); let isWk = false; if (window.wxjs_is_wkwebview) &#123; isWk = true; &#125; window.wx.chooseImage(&#123; count: 4, // 默认9，最多选择几张 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: res =&gt; &#123; console.log(res); // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片 let localIds = res.localIds; localIds.forEach((item, index) =&gt; &#123; if (isWk) &#123; window.wx.getLocalImgData(&#123; localId: item, // 图片的localID success: res =&gt; &#123; let localData = res.localData; // 展示选中图片 this.setState(&#123; files: this.state.files.concat(&#123; url: localData, id: this.state.files.length + index, &#125;), &#125;); // localData是图片的base64数据，可以用img标签显示 &#125;, &#125;); &#125; else &#123; // 展示选中图片 this.setState(&#123; files: this.state.files.concat(&#123; url: item, id: this.state.files.length + index, &#125;), &#125;); &#125; // 上传图片 // window.wx.uploadImage(&#123; // localId: res.localIds[0], // 需要上传的图片的本地ID，由chooseImage接口获得 // isShowProgressTips: 0, // 默认为1，显示进度提示 // success: pic =&gt; &#123; // // this.uploadImage(pic.serverId).then(resp =&gt; &#123; // // if (resp.data) &#123; // // Toast('上传成功'); // // &#125; else &#123; // // Toast('上传失败'); // // &#125; // // &#125;); // &#125;, // &#125;); &#125;); &#125;, &#125;); &#125;; render() &#123; const &#123; getFieldProps &#125; = this.props.form; const &#123; files &#125; = this.state; return ( &lt;div&gt; &lt;Li&gt; &lt;Texta &#123;...getFieldProps('count', &#123; // initialValue: '描述您遇到的问题或建议', &#125;)&#125; rows=&#123;4&#125; count=&#123;200&#125; placeholder="描述您遇到的问题或建议" /&gt; &lt;/Li&gt; &lt;Screenshots&gt; &lt;SsText&gt;相关截图&lt;/SsText&gt; &lt;SsCount&gt;0/4&lt;/SsCount&gt; &lt;/Screenshots&gt; &lt;ImgSel&gt; &lt;ImagePicker length="4" files=&#123;files&#125; onChange=&#123;this.onChange&#125; onImageClick=&#123;this.onImageClick&#125; selectable=&#123;files.length &lt; 4&#125; onAddImageClick=&#123;this.onAddImageClick&#125; /&gt; &lt;/ImgSel&gt; &lt;WingBlank&gt; &lt;Btn type="warning"&gt;提交&lt;/Btn&gt; &lt;/WingBlank&gt; &lt;/div&gt; ); &#125;&#125;const Feedback = createForm()(Feedbackkk);export default Feedback;const Li = styled(List)` padding: $&#123;rem('0 15px')&#125;; background: #fff; .am-list-item.am-textarea-item &#123; padding: 0 !important; &#125;`;const Texta = styled(TextareaItem)` .am-textarea-control textarea &#123; font-size: $&#123;rem('14px')&#125;; &#125; .am-textarea-count &#123; color: #999; transform: translateX($&#123;rem('4px')&#125;); margin-bottom: $&#123;rem('10px')&#125;; &#125; .am-textarea-count span &#123; color: #999999; &#125;`;const ImgSel = styled.div` background: #fff; .am-image-picker-list &#123; padding: $&#123;rem('0 15px 23px 15px')&#125;; &#125;`;const Screenshots = styled.div` background: #fff; display: flex; justify-content: space-between; align-items: center; padding: $&#123;rem('12px 15px 8px 15px')&#125;;`;const SsText = styled.div` font-size: $&#123;rem('16px')&#125;; color: #595959;`;const SsCount = styled.div` font-size: $&#123;rem('14px')&#125;; color: #999999;`;const Btn = styled(Button)` span &#123; font-size: $&#123;rem('18px')&#125;; &#125;`;const III = styled.img` width: 80px; height: 80px;`;const CCC = styled.img` width: 80px; height: 80px;`;const Add = styled.div` width: 80px; height: 80px; border: 1px solid #000;`;]]></content>
      <categories>
        <category>微信网页版</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>antd-mobile</tag>
        <tag>微信JS-SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于mpvue+weui+mpvue-router-patch的小程序]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%9F%BA%E4%BA%8Empvue-weui%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[原文文档出自http://kuangpf.com/mpvue-weui/#/README项目出自https://github.com/RebeccaHanjw/weapp-wechat-zhihu 其他的小程序UI框架:https://github.com/weilanwl/ColorUI 最近用基于vue的mpvue框架以及类似ui库的东西（http://kuangpf.com/mpvue-weui/#/grid）搭建了一个类似知乎的小程序。 开发步骤1234$ vue init mpvue/mpvue-quickstart my-project$ cd my-project$ npm install$ npm run dev 将项目放在微信web开发工具中即可。（生成的dist文件夹才是转换的微信小程序） 使用mpvue-weui在/src/main.js中引入weui.css，然后就可以使用了提供一个链接weui.css 使用mpvue-router-patchhttps://www.npmjs.com/package/mpvue-router-patch1$ npm install mpvue-router-patch 在src文件夹下main.js引入如下代码：1234import Vue from &apos;vue&apos;import MpvueRouterPatch from &apos;mpvue-router-patch&apos; Vue.use(MpvueRouterPatch) 跳转到某个页面1$router.push(location, onComplete?, onAbort?, onSuccess?) 跳转到应用内的某个页面，wx.navigateTo、wx.switchTab 及 wx.reLaunch 均通过该方法实现，location 参数支持字符串及对象两种形式，跳转至 tabBar 页面或重启至某页面时必须以对象形式传入1234567891011121314// 字符串router.push(&apos;/pages/news/detail&apos;) // 对象router.push(&#123; path: &apos;/pages/news/detail&apos; &#125;) // 带查询参数，变成 /pages/news/detail?id=1router.push(&#123; path: &apos;/pages/news/detail&apos;, query: &#123; id: 1 &#125; &#125;) // 切换至 tabBar 页面router.push(&#123; path: &apos;/pages/news/list&apos;, isTab: true &#125;) // 重启至某页面，无需指定是否为 tabBar 页面，但 tabBar 页面无法携带参数router.push(&#123; path: &apos;/pages/news/list&apos;, reLaunch: true &#125;)]]></content>
      <categories>
        <category>ui框架</category>
      </categories>
      <tags>
        <tag>mpvue</tag>
        <tag>weui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客同时部署到github和Coding]]></title>
    <url>%2F2018%2F09%2F03%2Fhexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%92%8CCoding%2F</url>
    <content type="text"><![CDATA[原文：http://www.voidcn.com/article/p-psfdomxz-yz.html 引言：之前博客只部署到了github上，具体过程可参考基于hexo+github博客的搭建，我尝试同时部署到coding上。 1.打开Coding.net官网，注册个人账号。这里我直接关联的github账号。 2.新建项目注意：项目名与注册用的账户名一致。 3.将根目录下的_config.yml的repo写成1234repo: github: https://github.com/账户名/账户名.github.io.git,master coding: https://git.coding.net/帐户名/账户名.git,master 4.部署即可12$ hexo g$ hexo d 5.打开Coding.net的项目管理界面，打开代码-&gt;Pages服务，选择部署来源为master分支，然后保存即可。 6.访问地址：账户名.coding.me]]></content>
      <categories>
        <category>博客开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习/前端工具的网址]]></title>
    <url>%2F2018%2F09%2F03%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[这里将前端学习的网址，以及前端使用的一些工具记录了下来。 1 印记中文https://docschina.org/#test 2 autoprefixer csshttp://autoprefixer.github.io/将css转换为兼容各浏览器的代码 3 JSON在线解析http://json.awesomes.cn/ 4 Immutable.jshttps://facebook.github.io/immutable-js/提供了许多永久不可变的数据结构 5 react-ui框架——antdhttps://ant.design/ 6 微信网页版真机调试-可看到console.log电脑：chrome://inspect/#devices手机：http://debugx5.qq.com 手机上点击信息，勾选打开TBS内核Inspector调试功能和打开TBS内核X5jscore Inspector调试功能电脑端打开Inspector字样，就可出现调试界面 7 mockhttp://mockjs.com/examples.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>网址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F09%2F03%2Fwebpack%2F</url>
    <content type="text"><![CDATA[用webpack进行项目打包。本文出自https://juejin.im/entry/58c2023dda2f600d8722043a 概念——开发与发布在开发阶段需要测试，看程序是否跑通。而测试工具在发布时是不需要的，为了分别管理，npm在package.json提供了这个字段 devDependencies ——仅开发依赖dependencies ——依赖包 开发与部署部署会用到和开发阶段不同的webpack配置文件，将输出目录换了另一个。 app 放文件的地方build文件夹 是经过webpack打包，自动生成文件的去处。dist文件夹 保存发布版本在.app中写东西，打包到build中调试，再发布到dist文件夹 配置webpack webpack.config.js 目标buildwebpack.production.config.js 目标dist需要手写。12345678910// webpack.config.jsvar path = require(&quot;path&quot;);module.exports = &#123; entry: path.join(__dirname, &apos;/app/main.js&apos;), output: &#123; path: path.join(__dirname, &apos;/build&apos;),//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125;; __dirname 是当前运行的js所在的目录 模块的依赖书写方式：require——commonJSimport/export——ES6 module import（需要babel转换器） 配置属性1.entry 入口 entry值的写法 123entry: path.resolve(__dirname, &apos;app&apos;);entry: path.join(__dirname, &apos;app&apos;);entry: __dirname + &apos;/app&apos;;(linux, mac下正确， windows下错误) path.resolve() 做一些解析，将参数从右到坐拼接，直到遇到一个绝对路径 /表示路径起点——绝对路径的标志，通常为脚本运行所处的位置path.join() 仅仅进行路径拼接 2.context——entry的根目录可以通过context来定义entry的根目录1234&#123; context: path.join(__dirname, &apos;app&apos;), entry: &apos;entry&apos;&#125; 3.output https://www.jianshu.com/p/dcb28b582318规定如何将打包后的文件写在磁盘里output.path 仅仅告诉webpack结果存储到哪儿output.publicPath 被许多webpack的插件用于在生产模式下更新 内嵌到css,html文件里的url值 4.webpack-dev-server 服务器工具1$ npm install --save-dev webpack-dev-server server内部调用webpack，好处是提供了额外的功能，如热更新“Live Reload”以及热替换“Hot Module Replacement”[HMR] hot模块（局部刷新）[WDS] webpack-dev-server模块使用react-hot-loader1npm install --save-dev react-hot-loader@3.0.0-beta.6 使用babel，若babel配置太多，就新建.babelrc1npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react babel-preset-stage-2]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客保存源代码]]></title>
    <url>%2F2018%2F08%2F29%2Fhexo%E5%8D%9A%E5%AE%A2%E4%BF%9D%E5%AD%98%E6%BA%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[hexo默认上传代码至github仓库时，会自动将文件进行打包转换为.deploy_git中的代码，这样，我们用别的电脑继续书写博客，就会存在找不到源文件的问题。所以，针对这个问题，我重新开了一个分支来保存源码，步骤已列出，希望给大家带来一些帮助。 在根目录中放置一个git文件，以便将代码上传至github1$ git init git文件夹中的 config 放至以下内容， 注意url中的地址需要是Use HTTPS，不是SSH。（如果电脑上不需要添加账户密钥就用HTTPS的地址，这样无论在何时都可以更新博客了） 根目录下的 _config.yml也需要将地址更改为Use HTTPS12345678910[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;origin&quot;] url = https://github.com/用户名/用户名.github.io.git fetch = +refs/heads/*:refs/remotes/origin/* 在GitHub仓库中创建一个新分支，git创建一个同样的分支并切换到此分支，执行以下代码：在这里我用的git的上传工具，TortoiseGit。123$ git pull $ git commit$ git push 然后，就可以在github的分支上面看到hexo的源代码了 若推送时，警告说已存在这个仓库，就删掉仓库中的分支，执行以下代码：1$ git push origin :需要去掉的分支的名字]]></content>
      <categories>
        <category>博客开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node搭建服务器]]></title>
    <url>%2F2018%2F03%2F22%2Fnode%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用node搭建一个简单的服务器1.新建文件夹，在里面再创建一个文件夹server2.在server里面12npm init 创建一个package.jsonnpm i --save express(npm i -S express) 安装express 3.创建app.js(index.js)123const express = require(&quot;express&quot;);let app = new express();app.listen(3000); 4.打开服务器安装：npm i -g supervisor1cmd:supervisor app|node app 地址栏localhost:30005.全局安装隧道服务12cmd:npm i -g ngrok任意位置:ngrok http 3000 或者网页安装（http://ngrok.com/download）C:/ngrok.exe之后在C盘web-01里面将ngrok打开，并解压到桌面1C:/ cmd:ngrok.exe http 3000 6.server/1npm i -S wechat 7.app.js123456const wechat = require(&quot;wechat&quot;);let config = &#123; appid:&apos;&apos;, token:&apos;&apos;, encodingAESKey:&apos;&apos;&#125; 8.微信公众平台-登录个人订阅号账号开发-基本配置复制AppId,粘贴为config的AppID值9.开发-基本配置服务器(未启用)-修改配置token:weixinencodingAESKey:随机生成10.复制ngrok生成的隧道地址，填写到公众平台的url处11.app.js12345app.get(&apos;/&apos;,wechat(config,(req,res)=&gt;&#123; let message = req.weixin console.log(message)&#125;)) 12.开发-基本配置服务器配置（未启用）-修改配置提交 13.启用开发者模式服务器配置（已启用） 14.在公众号中输入消息，后台可以看到。15.在公众号中输入消息，可以自动回复。返回响应：res.reply(“收到”) 16.模拟编辑模式的关键词半匹配回复。12345678910111213141516171819const express = require(&quot;express&quot;);const wechat = require(&quot;wechat&quot;);let config = &#123; appid:&apos;wx8c42dec7e3b4dc1f&apos;, token:&apos;weixin&apos;, encodingAESKey:&apos;utC2otCu4vW0F86XpHIQZ9kx71I9fcltwDvbGFNk3Il&apos;&#125;;let app = new express();app.post(&apos;/&apos;,wechat(config,(req,res)=&gt;&#123; let message = req.weixin console.log(message.Content) res.reply(&quot;收到&quot;)&#125;))app.listen(3000); 1234567891011121314151617181920212223242526272829303132333435363738394041const express = require(&quot;express&quot;);const wechat = require(&quot;wechat&quot;);const mysql=require(&quot;mysql&quot;);const pool = mysql.createPool(&#123; user:&apos;root&apos;, connectionLimit:5&#125;)let config = &#123; appid:&apos;wx8c42dec7e3b4dc1f&apos;, token:&apos;weixin&apos;, encodingAESKey:&apos;utC2otCu4vW0F86XpHIQZ9kx71I9fcltwDvbGFNk3Il&apos;&#125;;let app = new express();app.post(&apos;/&apos;,wechat(config,(req,res)=&gt;&#123; let message = req.weixin.Content console.log(message) //if(message.includes(&apos;JavaScript&apos;))&#123; // res.reply(&apos;JS...&apos;) //&#125;else if(message.includes(&apos;HTML&apos;))&#123; // res.reply(&apos;HTML...&apos;) //&#125;else if(message.includes(&apos;CSS&apos;))&#123; // res.reply(&apos;CSS&apos;) //&#125; let sql = `SELECT * FROM db.chat WHERE ? LIKE CONCAT(&apos;%&apos;+question+&apos;%&apos;)`; pool.query(sql,[message],(err,result)=&gt;&#123; //返回answer if(result.length==1)&#123; res.reply(results[0].answer) &#125;else&#123; res.reply(&apos;啊？&apos;) &#125; &#125;)&#125;))app.listen(3000);]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题汇总]]></title>
    <url>%2F2018%2F03%2F08%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[哈哈 1、一个优秀的前端开发人员需要具备哪些特质？做完，做好，分享。 2、常见的布局方式有哪些？(1)固定布局：页面被一个固定的网页包裹，容器不能移动，页面的宽高也不随页面的变化而变化，灵活性不高。(2)流式布局：屏幕自适应，根据屏幕的情况变化，不容易控制，PC端用的不是非常多。(3)弹性布局：ie9以下浏览器都不支持。(4)浮动布局(5)定位布局(6)margin和padding 3、页面导入样式时的常见方式有哪些？link，import 4、常见的解决浏览器兼容性问题的方式有哪些？5、html5有哪些新特性？6、网页验证码是干嘛的？是为了解决什么安全问题？7、介绍一下标准的css的盒子模型？8、如何居中div，如何居中一个浮动元素？如何让绝对定位的div居中？9、position的值relative和absolute的区别什么10、display设置为inline-block时，li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车空格等等）的影响，这些空白也会被应用样式，占据空间，所以会有间隔解决：设置ul的font-size为0，缺陷是必须重新在li中去设置字体大小 11、请解释下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？12.创建对象的3种方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950511)工厂模式&gt;考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节function createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125; return o; &#125; var person1 = createPerson(&apos;Grey&apos;,27,&apos;Doctor&apos;);&gt;工厂函数不必使用new关键字，可以消除对象间的耦合。解决了重复实例化的问题，但无法搞清楚他们是哪个对象的实例。2)构造函数模式：解决了重复实例化的问题，与对象识别的问题。没有return。&gt;什么是构造函数：描述一类对象统一结构的函数。function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125; &#125; var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); var person2 = new Person(&apos;Grey&apos;,27,&apos;Doctor&apos;);&gt;*new的时候干了4件事：&gt;创建一个新对象；&gt;this指向这个新对象（将构造函数的作用域赋给新对象）；&gt;为这个新对象添加属性和方法（执行构造函数中的代码）&gt;返回新对象3)原型模式&gt;我们创建的每一个函数都有一个prototype(原型对象)，&gt;原型对象的好处是可以让所有对象实例共享它所包含的属性和方法&gt;换句话说，不必在构造函数中定义对象的所有信息，而是将这些信息直接添加到原型对象中&gt;与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。function Person()&#123;&#125; Person.prototype.name = &apos;Nicholas&apos;; Person.prototype.age = 29; Person.prototype.job = &apos;Software Engineer&apos;; Person.prototype.sayName = function()&#123; alert(this.name); &#125; var person1 = new Person(); person1.sayName();//&quot;Nicholas&quot; var person2 = new Person(); person2.sayName(); //&quot;Nicholas&quot; alert(person1.sayName == person2.sayName); //true 13.哪种方式更高效：document.getElementbyId(“myId”) 还是 $(“#myId”)？1第一种：直接调用了js引擎。第二种会判断该使用哪种方式获取 14.关于跨域123456789(1)造成跨域的两种策略：DOM同源策略：禁止对不同源页面DOM进行操作。主要场景是iframe跨域的情况，不同域名的iframe是限制相互访问的，在同一个页面中也不许访问。XMLHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起http请求。*只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。(2)如何实现跨域？&gt;&gt;&gt;跨域资源共享（CORS）：客户端，使用正常的xhr对象发送ajax请求，设置xhr.withCredentials=true(将cookie带过去)；服务器端，response header中设置Access-Control-Allow-Origin:yourhost.com Access-Control-Allow-Credentials:true&gt;&gt;&gt;jsonp实现跨域*jsonp不能发post请求，只支持GET请求&lt;script&gt;标签没有跨域限制，json是一种数据格式；jsonp是一种数据调用方式，可以理解为jsonp是带有callback的json，服务器端echo callback+&apos;(&apos;+json+&apos;)&apos;; 15.jQuery.get() 和 jQuery.ajax() 方法之间的区别是什么?12*jQuery.ajax() 方法更强大，更具可配置性, 让你可以指定等待多久，以及如何处理错误。*jQuery.get() 只获取数据的专门方法 16.ajax123(1)什么是ajax？为什么要使用ajax？*ajax被称为异步的JavaScript和XML，是实现异步交互的主要技术。*优点：ajax可以实现页面的局部数据更新（页面不刷新就可以更新数据），对带宽和服务器的压力减小；缺点：浏览器的后退按钮失效，搜索引擎无法抓取，破坏代码的整体执行流程，不容易查找错误。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何存储对象（深拷贝）]]></title>
    <url>%2F2018%2F03%2F08%2F%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[12JSON.parse(JSON.stringify(对象)):深拷贝：会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object，遇到循环引用（自己引用自己）也无法处理 1Object.assign(&#123;&#125;,对象)：深拷贝一级属性，包括prototype，若属性是引用类型，需要递归复制。 浅拷贝指向同一地址，修改属性值会影响另一个]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用less定制bootstrap的过程]]></title>
    <url>%2F2018%2F03%2F04%2F%E4%BD%BF%E7%94%A8less%E5%AE%9A%E5%88%B6bootstrap%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本例更改了导航部分的颜色。 定制完成之后就可以进行编译了。]]></content>
      <categories>
        <category>前端编译器</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>less</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue重构项目遇到的问题以及vue项目打包]]></title>
    <url>%2F2018%2F03%2F04%2F08vue%2F</url>
    <content type="text"><![CDATA[本文描述的是在用vue重构项目时所遇到的一些问题。在此记录一下。 1.如果图片的路径是变量，需要用require(“路径变量”)2.子组件之间的通信(1)在全局定义window.bus。 通知：bus.$emit(“事件名称”,数据)接收：bus.$on(“事件名称”,function(msg){}) (2)或者使用本地存储技术 localStorage/sessionStorage.setItem(“名称”,数据)localStorage/sessionStorage.getItem(“名称”)localStorage/sessionStorage.removeItem(“名称”) 3.怎样刷新页面，局部刷新？？this.$router.push(“/路径”)不支持刷新 window.location.reload()是刷新整个页面，我想只刷新某部分的router-viewthis.$router.go(0);刷新整个页面 4.关于通信问题。(1)父与子：① props② $refs③ $parent(2)子与父：子：$emit.事件 父：标签中 @事件=”” (3)子与子bus子1（传递$emit）: 子2（绑定$on）： vue环境搭建 vue项目打包1.config/index.js2.build/utils.js3.根目录下运行npm run build4.完成后文件保存在根目录下的dist，需要打开服务器，才能打开index.html vue-router的导航钩子1.全局导航钩子（前置守卫、后置钩子）（1）全局前置守卫12345678const router = new VueRouter(&#123;...&#125;)router.beforeEach((to,from,next)=&gt;&#123; //do something&#125;)to:Route，代表要进入的目标，它是一个路由对象from:Route，代表当前正要离开的路由，同样也是一个路由对象next:Function，这是一个必须需要调用的方法，而具体的执行效果则依赖next方法调用的参数 （2）全局后置钩子:不同于前置守卫，后置钩子没有next函数，也不会改变导航本身。123router.afterEach((to,from)=&gt;&#123; //do something&#125;) 2.路由独享的钩子：在路由配置上直接定义的：1234567891011cont router = new VueRouter(&#123; routes:[ &#123; path:&apos;/file&apos;, component:File, beforeEnter:((to,from,next)=&gt;&#123; //do something &#125;) &#125; ]&#125;) 3.组件内的导航钩子4.父组件向子组件传递props（异步请求回来的数据）时，在子组件的生命周期挂载后，数据为undefined,用定时器延迟来接收即可。5.改变对象或数组不会触发DOM更新，解决办法：123eg: const obj = that.keywordList[key] obj.checked = !obj.checked that.leywordList.splice(index, 1, obj) 6.若需要动态添加元素的CSS,则不能写scoped属性7.nextTick:在视图更新之后，基于新的视图进行操作。看一个例子：点击show按钮使得原来v-show：false的input输入框显示，并获取焦点：123456789101112131415161718192021 &lt;div id=&quot;app&quot;&gt; &lt;input ref=&quot;input&quot; v-show=&quot;inputShow&quot;&gt; &lt;button @click=&quot;show&quot;&gt;show&lt;/button&gt; &lt;/div&gt;new Vue(&#123; el: &quot;#app&quot;, data() &#123; return &#123; inputShow: false &#125; &#125;, methods: &#123; show() &#123; this.inputShow = true this.$nextTick(() =&gt; &#123; this.$refs.input.focus() &#125;) &#125; &#125;&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懒加载与预加载]]></title>
    <url>%2F2018%2F03%2F01%2F07lazyload%2F</url>
    <content type="text"><![CDATA[懒加载和预加载是开发中常用的设计模式，实现方式也有很多，在项目中我使用了懒加载，在这里简单记录一下。 1.懒加载1.1什么是懒加载？ 懒加载通俗的讲就是延迟加载。图片懒加载就是当页面滚动到可视区域时，图片才显示出来。 1.2.懒加载的原理。 页面中的img，如果没有src属性，浏览器就不会去下载图片。把页面中所有的图片路径都设置为空（或者用一个小的图片代替（1px*1px）），当滚动到可视区域的时候才设置图片正确的路径。图片真正的路径用自定义属性保存，比如data-src. 1.3.为什么要使用懒加载，懒加载的优点？ 比如商城网站，有很多内容和图片，数量多而且比较大，如果页面一次性加载的话，有时候会等很久。优点：页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好。目的是作为服务器前端的优化，减少请求数或延迟请求数。 1.4.懒加载的实现步骤 （1）将img的src=””（2）为img添加data-src=”图片真正路径”（3）当触发某些条件时，自动改变该区域的图片的src属性为真实的地址12345678910111213141516171819img = $(&apos;img&apos;);// 页面刷新时首先调用一次加载函数lazyload();// 注册滚动监听函数$(window).scroll(lazyload);//懒加载函数function lazyload()&#123; for(var i=0;i&lt;img.length;i++)&#123; //当前图片相对于页面顶部的距离 &lt;= 可视区域 + 滚动条距离距离顶部的距离 -400。 if(img.eq(i).offset().top &lt; parseInt($(window).height()) + parseInt($(window).scrollTop())-400) &#123; // 如果每个img的src为空的话，给每个img的src赋值为data-src的值 if(img.eq(i).attr(&quot;src&quot;) == &quot;&quot;) &#123; var src = img.eq(i).attr(&quot;data-src&quot;); img.eq(i).attr(&quot;src&quot;, src); n = i + 1; &#125; &#125; &#125;&#125; 1.5懒加载的实现方式 1.定时器延迟加载2.符合某些条件才加载3.可视区加载，距用户看到某个图片一定距离时开始加载，保证用户下拉时可以看到图片，监控滚动条来实现。 2.预加载2.1什么是预加载？ 提前加载图片，当用户需要查看时可直接从本地缓存中渲染。 2.2为什么要使用预加载，预加载的优点？ 图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。优点：牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映。 2.3预加载的实现方式 new Image();http://web.jobbole.com/86785/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>javascipt</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云上传数据库与后台书写]]></title>
    <url>%2F2018%2F02%2F27%2F06php%2F</url>
    <content type="text"><![CDATA[有些同学可能在本地服务器测试从后台请求回来的数据是正确的，但是上传到阿里云后就不可以了，原因在本文中已经帮同学们列举出来了。 需要大家知道的一点是，当我们在PHP中使用mysqli_fetch_all($result,MYSQLI_ASSOC)，并且将这段代码放到线上环境时，那么就会发现没有请求回来的结果，所以，此函数是无法使用的。通过搜索后知道，连接MySQL存在两套连接驱动（libmysql（老）和mysqlind（新））。阿里云只认libmysql。mysqlind是后来出现的。 mysqlnd(MySQL Native Driver)是老版本中php的mysql连接库libmysqlclient（ MySQL Client Library）的一个新的替代。mysqlnd从PHP 5.3.0开始就内置在官方发布的php源码包中。从 http://www.runoob.com/php/func-mysqli-fetch-all.html 中可以知道，mysqli_fetch_all()函数只在带有 MySQL Native Driver 时可用。 这是我的主机php使用的版本，由于是5.2.0，所以连接驱动是libmysql 需要注意两点：1.需要在php中使用mysqli_fetch_array()代替mysqli_fetch_all()，用法如下： 2.不可以使用 $arr=[] 来直接定义数组，需要使用 $arr = array() 定义数组。 关于mysqlind的更多新特性见 http://www.360doc.com/content/14/0811/17/17265359_401083295.shtml]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于主题内容的配置]]></title>
    <url>%2F2018%2F02%2F23%2F05%E4%B8%BB%E9%A2%98%E5%86%85%E5%AE%B9%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一篇文章中的设置(.md) 1.标签和分类的书写标题下的分类与最下面的标签，在文件头部分别设置1234567---title: xxxxxxcategories:- webtags:- hexo--- 2.按钮Read More在哪里设置按钮，就在哪里断开内容，下面写的内容就在链接里面1`&lt;!-- more --&gt;` 3.tags和catogories的配置先创建新页面12$ hexo new page tags$ hexo new page categories 在页面中写123456789---title: xxxxxxlayout: &quot;tags&quot;------title: xxxxxxlayout: &quot;categories&quot;--- 4.搜索安装插件1$ npm install hexo-generator-json-content 在根目录的配置中添加123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 5.评论：使用GitHub的issue添加评论功能 主题中的_.config.yml：123456comment: enable: true #是否开启评论功能 owner: xuxut #github 账户名 repo: blog_comments #存储评论的仓库 注意：与博客用的不是同一个仓库 client_id: 631adc330b6c1dea6507 #oAuth的client_id client_secret: 957d552e22d621653e22f155a00b0363058317fc #oAuth的client_secret 关于github oAuth的配置：如果在本地调用GitHub的登录和评论，两个地址都设置为本地的地址http://localhost:4000/]]></content>
      <categories>
        <category>博客开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内容的编写和图片引用]]></title>
    <url>%2F2018%2F02%2F23%2F04%E5%86%85%E5%AE%B9%E7%BC%96%E5%86%99%E5%92%8C%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍一下基于hexo+github博客内容的编写与图片引用出现的问题。 1.这里介绍一种非常方便的写法打开博客根目录，进入/source/_post/xxx.md，新建一个后缀名为md的文件，语法格式请参考“Markdown 语法整理大集合2017”地址为：https://www.jianshu.com/p/b03a8d7b1719 2.关于图片引用的问题，请参考https://www.jianshu.com/p/cf0628478a4e修改根目录下的_config.yml配置文件post_asset_folder项为true。1post_asset_folder: true 新建文件，图片放在对应文件夹下，用 ![](./图片.jpg &#39;图片描述&#39;) 引用图片1$ hexo new 文件名 3.超链接 链接名]]></content>
      <categories>
        <category>博客开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍主题的修改]]></title>
    <url>%2F2018%2F02%2F23%2F03%E4%BB%8B%E7%BB%8D%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[介绍一下基于hexo+github博客主题的修改。 进入https://hexo.io/themes/找到自己喜欢的主题风格①点击图片，浏览效果 点击标题，进入GitHub，在仓库里有些可以看到具体过程，比如：http://blog.shanamaid.top/②若仓库里没有具体介绍，可以大致依照以下步骤：(1)安装主题1$ git clone 主题地址 themes/主题名称 (2)配置主题：修改根目录下的_config.yml1theme:主题名称 (3)更新后12$ cd themes/主题名称$ git pull origin master (4)生成页面，并上传至GitHub从目录中回到根目录12$ cd ..$ cd .. 12$ hexo g$ hexo d (5)配置文件：根目录\themes\主体名称_config.yml自定义代码高亮：根目录\themes\主体名称\source\css_partial\highlight.styl下第17行自定义背景图片：根目录\themes\主体名称\source\plugin\bganimation\bg.css (6)使用GitHub的issue添加评论功能 主题中的_.config.yml：123456comment: enable: true #是否开启评论功能 owner: xuxut #github 账户名 repo: blog_comments #存储评论的仓库 注意：与博客用的不是同一个仓库 client_id: 631adc330b6c1dea6507 #oAuth的client_id client_secret: 957d552e22d621653e22f155a00b0363058317fc #oAuth的client_secret 关于github oAuth的配置：如果在本地调用GitHub的登录和评论，两个地址都设置为本地的地址https://localhost:4000]]></content>
      <categories>
        <category>博客开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于hexo+github博客的搭建]]></title>
    <url>%2F2018%2F02%2F22%2F02hexo%2F</url>
    <content type="text"><![CDATA[介绍一下基于hexo+github博客的搭建（很基础）。 1.建立空文件夹任意地方建立空文件夹（自己找的到）来存放一些必要的子目录文件。比如（我自己的myblog）： 2.安装node检测node是否已安装:打开myblog，按住shift+鼠标右键，输入以下命令1$ node -v 若没有，请自行安装 3.安装hexo安装hexo之前必须确保已安装node。之后执行以下代码①安装hexo1$ npm install -g hexo 正在安装中…安装成功！！！ ②初始化hexo，生成一些文件1$ hexo init ③安装所需要的组件1$ npm install ④生成静态页面，并部署到页面12$ hexo g$ hexo d ⑤打开服务器1$ hexo s ⑥浏览器地址栏输入localhost:4000，可以看到本地博客。且在本地修改内容也可以。 4.建立GitHub仓库首先申请GitHub账号，如何申请自己网上搜索。进入GitHub， 5.将本地博客连入GitHub仓库①安装git在空白区域单击右键，若出现以下内容，说明电脑已安装git。若没有，请自己安装 ②设置用户名和邮箱在myblog文件夹中点击右键，点击Git Base Here输入自己的用户名和邮箱1$ git config --global user.name "xxx" 1$ git config --global user.email "xxxx@xx.com" 1$ git init ③检查是否有.ssh的文件夹1$ cd ~/.ssh 若以前没有.ssh文件夹，则显示： ④生成密匙1$ ssh-keygen -t rsa -C "xxxx@xx.com" 此处填写自己的邮箱连续三个回车可以看到创建了一个.ssh的文件夹（包含id_rsa和id_rsa.pub两个文件），并生成密匙。（两个文件存储路径默认在图中所示，不同电脑有所不同） ④再次检查.ssh文件夹1$ cd ~/.ssh ⑤进入ssh文件夹，输入ls，出现id_rsa id_rsa.pub，说明生成密匙成功。1$ ls ⑥输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent1$ eval "$(ssh-agent -s)" ⑦再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent1$ ssh-add ~/.ssh/id_rsa ⑧登录GitHub，打开首页的右下角仓库。 ⑨测试添加ssh是否成功。出现(yes/no)，输入yes。若看到 Hi 后面是你的用户名，说明成功了。1$ ssh -T git@github.com 6.配置Deployment，在myblog（最开始建立的文件夹）中，找到_config.yml文件，在末尾进行修改。repo值是在仓库里的右下角 7.安装扩展①打开myblog文件夹，单击右键+shift。点击“在此处执行命令窗口” ②安装扩展（hexo部署）1$ npm install hexo-deployer-git --save ③生成静态页面，发布到GitHub12$ hexo g $ hexo d ④连接成功后会出现一个弹出框。输入自己的用户名/邮箱，密码即可成功了就访问地址 http://用户名.github.io，可以看见页面了 若此处出错，则修改地址，运行以下代码：（在git bash中执行）1$ git remote add origin git@github.com:用户名/用户名.github.io.git 打开myblog下的_config.yml，修改repo 12$ hexo g$ hexo d 访问地址 http://用户名.github.io]]></content>
      <categories>
        <category>博客开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git和vscode安装文档]]></title>
    <url>%2F2018%2F02%2F11%2Fgit%E5%92%8Cvscode%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[nodehttps://nodejs.org/zh-cn/download/ githttps://git-scm.com/downloads npm-cnpm-yarn-tyarn12345678npm -vnpm install cnpm -g --registry=https://registry.npm.taobao.orgcnpm -vcnpm install yarn tyarn -gyarn -vtyarn -v visual studio codehttps://visualstudio.microsoft.com/zh-hans/downloads/ 插件： 1234567891011121314Auto Close TagAuto Complete TagAuto Rename TagBeautifyChinese (Simplified) LanguageES7 React/Redux/GraphQL/React-Native snippetsGit HistoryGitLens -Git superchargedHTML CSS SupportHTML Snippetsnpm IntellisensePath IntellisenseReact/Redux/react-router SnippetsReactjs code snippets 设置：setting.json 123456789101112&#123; "workbench.editor.enablePreview": false, "git.ignoreMissingGitWarning": true, "editor.fontSize": 18, "window.zoomLevel": 1, "git.path": "D:\\git\\Git\\bin\\git.exe", "emmet.includeLanguages": &#123; "javascript": "javascriptreact" &#125;, "javascript.implicitProjectConfig.experimentalDecorators": true, "git.confirmSync": false,&#125; 添加git的环境变量右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量administrator下的Path添加D:\git\Git\bin 常用快捷键ctrl+p 打开某个文件ctrl+g 去某一行ctrl+shift+p 使用git 左侧应用 123左侧搜索全局使用git插件安装 项目地址https://code.aliyun.com/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F22%2F01hello-world%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
