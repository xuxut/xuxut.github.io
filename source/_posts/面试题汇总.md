---
title: 面试题汇总
date: 2018-03-08 18:59:49
tags:
- js
categories:
- 前端
---

哈哈

<!-- more -->

## 1、一个优秀的前端开发人员需要具备哪些特质？
做完，做好，分享。
## 2、常见的布局方式有哪些？
(1)固定布局：页面被一个固定的网页包裹，容器不能移动，页面的宽高也不随页面的变化而变化，灵活性不高。
(2)流式布局：屏幕自适应，根据屏幕的情况变化，不容易控制，PC端用的不是非常多。
(3)弹性布局：ie9以下浏览器都不支持。
(4)浮动布局
(5)定位布局
(6)margin和padding
## 3、页面导入样式时的常见方式有哪些？
link，import
## 4、常见的解决浏览器兼容性问题的方式有哪些？
## 5、html5有哪些新特性？
## 6、网页验证码是干嘛的？是为了解决什么安全问题？
## 7、介绍一下标准的css的盒子模型？
## 8、如何居中div，如何居中一个浮动元素？如何让绝对定位的div居中？
## 9、position的值relative和absolute的区别什么
## 10、display设置为inline-block时，li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？
行框的排列会受到中间空白（回车空格等等）的影响，这些空白也会被应用样式，占据空间，所以会有间隔
解决：设置ul的font-size为0，缺陷是必须重新在li中去设置字体大小
## 11、请解释下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？

## 12.创建对象的3种方式
```
1)工厂模式
>考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节
function createPerson(name,age,job){
　　　　var o = new Object();
　　　　o.name = name;
　　　　o.age = age;
　　　　o.job = job;
　　　　o.sayName = function(){
　　　　　　alert(this.name);
　　　　}
　　　　return o;
　　}
　　var person1 = createPerson('Grey',27,'Doctor');
>工厂函数不必使用new关键字，可以消除对象间的耦合。解决了重复实例化的问题，但无法搞清楚他们是哪个对象的实例。

2)构造函数模式：解决了重复实例化的问题，与对象识别的问题。没有return。
>什么是构造函数：描述一类对象统一结构的函数。
function Person(name,age,job){
　　　　this.name = name;
　　　　this.age = age;
　　　　this.job = job;
　　　　this.sayName = function(){
　　　　　　alert(this.name);
　　　　}
　　}
　　var person1 = new Person("Nicholas", 29, "Software Engineer"); 
　　var person2 = new Person('Grey',27,'Doctor');
>*new的时候干了4件事：
>创建一个新对象；
>this指向这个新对象（将构造函数的作用域赋给新对象）；
>为这个新对象添加属性和方法（执行构造函数中的代码）
>返回新对象

3)原型模式
>我们创建的每一个函数都有一个prototype(原型对象)，
>原型对象的好处是可以让所有对象实例共享它所包含的属性和方法
>换句话说，不必在构造函数中定义对象的所有信息，而是将这些信息直接添加到原型对象中
>与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。
function Person(){
}
　　Person.prototype.name = 'Nicholas';
　　Person.prototype.age = 29;
　　Person.prototype.job = 'Software Engineer';
　　Person.prototype.sayName = function(){
　　　　alert(this.name);
　　}
　　var person1 = new Person();
　　person1.sayName();//"Nicholas"
　　var person2 = new Person(); 
　　person2.sayName(); //"Nicholas" 
　　alert(person1.sayName == person2.sayName); //true
```

## 13.哪种方式更高效：document.getElementbyId("myId") 还是 $("#myId")？
```
第一种：直接调用了js引擎。第二种会判断该使用哪种方式获取
```

## 14.关于跨域
```
(1)造成跨域的两种策略：
DOM同源策略：禁止对不同源页面DOM进行操作。主要场景是iframe跨域的情况，不同域名的iframe是限制相互访问的，在同一个页面中也不许访问。
XMLHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起http请求。
*只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。
(2)如何实现跨域？
>>>跨域资源共享（CORS）：客户端，使用正常的xhr对象发送ajax请求，设置xhr.withCredentials=true(将cookie带过去)；服务器端，response header中设置Access-Control-Allow-Origin:yourhost.com  Access-Control-Allow-Credentials:true
>>>jsonp实现跨域
*jsonp不能发post请求，只支持GET请求
<script>标签没有跨域限制，json是一种数据格式；jsonp是一种数据调用方式，可以理解为jsonp是带有callback的json，服务器端echo callback+'('+json+')';
```

## 15.jQuery.get() 和 jQuery.ajax() 方法之间的区别是什么?
```
*jQuery.ajax() 方法更强大，更具可配置性, 让你可以指定等待多久，以及如何处理错误。
*jQuery.get() 只获取数据的专门方法
```

## 16.ajax
```
(1)什么是ajax？为什么要使用ajax？
*ajax被称为异步的JavaScript和XML，是实现异步交互的主要技术。
*优点：ajax可以实现页面的局部数据更新（页面不刷新就可以更新数据），对带宽和服务器的压力减小；缺点：浏览器的后退按钮失效，搜索引擎无法抓取，破坏代码的整体执行流程，不容易查找错误。
```



